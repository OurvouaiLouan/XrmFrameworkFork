using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.EntityFrameworkCore.Internal;
using XrmFramework.Core;
using XrmFramework.Analyzers.Generators;

namespace XrmFramework.WebresourcesAnalyzers.Generators;

[Generator]
public class TableJsonDefinitionGenerator : BaseTableDefinitionGenerator
{
    protected override void WriteTable(SourceProductionContext productionContext, TableCollection tables, Table table,
        HashSet<string> alreadyCreatedEnums)
    {
        var sb = new IndentedStringBuilder();

        sb.AppendLine("#if COMPILE_JSON");

        sb.AppendLine("/*");
        sb.AppendLine(" * Auto generated by XrmFramework 2.0");
        sb.AppendLine(" * Do not edit directly this file");
        sb.AppendLine(" */");

        sb.AppendLine($"const {table.Name}Definition = {{");

        using (sb.Indent())
        {
            sb.AppendLine($"LogicalName: \"{table.LogicalName}\",");
            sb.AppendLine($"SchemaName: \"{table.Name}\",");
            sb.AppendLine($"CollectionName: \"{table.CollectionName}\",");
            sb.AppendLine($"LogicalCollectionName: \"{table.CollectionName}\",");
            sb.AppendLine(
                $"PrimaryIdAttribute: \"{table.Columns.FirstOrDefault(c => c.PrimaryType == PrimaryType.Id)?.LogicalName}\",");

            var primaryNameAttribute =
                table.Columns.FirstOrDefault(c => c.PrimaryType == PrimaryType.Name)?.LogicalName;

            var hasColumns = table.Columns.Count != 0;
            var hasEnums = table.Enums.Count != 0;

            sb.AppendLine($"PrimaryNameAttribute: \"{primaryNameAttribute}\"{(hasColumns || hasEnums ? "," : "")}");

            if (hasColumns)
            {
                WriteColumns(sb, table.Columns, hasEnums);
            }

            if (hasEnums)
            {
                WriteEnums(sb, table.Enums);
            }
        }

        sb.AppendLine("};");
        sb.AppendLine("#endif");

        /*
         * On crée le chemin pour cette table
         */
        productionContext.AddSource($"{ParseName(table.Name)}Definition.json",
            SourceText.From(sb.ToString(), System.Text.Encoding.UTF8));
    }

    private void WriteEnums(IndentedStringBuilder sb, List<OptionSetEnum> tableEnums)
    {
        sb.AppendLine("Enums: {");
        var highestIndex = tableEnums.Count - 1;
        using (sb.Indent())
        {
            for (int i = 0; i <= highestIndex; i++)
            {
                WriteEnum(sb, tableEnums[i], i == highestIndex);
            }
        }

        sb.AppendLine("}");
    }

    private void WriteEnum(IndentedStringBuilder sb, OptionSetEnum enumDefinition, bool isLast)
    {
        sb.AppendLine($"{ParseName(enumDefinition.Name)}: {{");
        using (sb.Indent())
        {
            WriteEnumValues(sb, enumDefinition.Values);
        }

        sb.AppendLine(isLast ? "}" : "},");
    }

    private void WriteEnumValues(IndentedStringBuilder sb, ICollection<OptionSetEnumValue> enumValues)
    {
        var highestIndex = enumValues.Count - 1;
        var jsonEnumValues = enumValues.Select((v, index) =>
            index == highestIndex
                ? $"{ParseName(v.Name)}: {v.Value}"
                : $"{ParseName(v.Name)}: {v.Value},");

        foreach (var jsonValue in jsonEnumValues)
        {
            sb.AppendLine(jsonValue);
        }
    }

    private void WriteColumns(IndentedStringBuilder sb, ColumnCollection tableColumns, bool hasNext)
    {
        sb.AppendLine("Columns: {");
        var highestIndex = tableColumns.Count - 1;
        var jsonColumns = tableColumns.Select((c, index) =>
            index == highestIndex
                ? $"{ParseName(c.Name)}: \"{c.LogicalName}\""
                : $"{ParseName(c.Name)}: \"{c.LogicalName}\","
        );

        using (sb.Indent())
        {
            foreach (var jsonColumn in jsonColumns)
            {
                sb.AppendLine(jsonColumn);
            }
        }

        sb.AppendLine(hasNext ? "}," : "}");
    }

    private string ParseAllCharacterOfAWord(string word, string valideCharacters)
    {
        if (string.IsNullOrEmpty(word)) return word;

        var finalWord = string.Concat(
            word
                .Where(charac => valideCharacters.Contains(charac))
        );

        return finalWord;
    }


    private string ParseFirstCharacterOfAWord(string word, string valideCharacters)
    {
        if (string.IsNullOrEmpty(word)) return "_";

        if (valideCharacters.Contains(word[0])) return word;
        else return "_" + word;
    }

    private string ParseName(string name)
    {
        const string allowedFirstCharacters = "_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

        const string digits = "0123456789";

        const string allowedCharacters = allowedFirstCharacters + digits;

        name = ParseFirstCharacterOfAWord(name, allowedFirstCharacters);

        name = ParseAllCharacterOfAWord(name, allowedCharacters);

        return name;
    }
}