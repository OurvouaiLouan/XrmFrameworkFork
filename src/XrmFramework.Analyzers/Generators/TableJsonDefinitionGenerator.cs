using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.EntityFrameworkCore.Internal;
using Newtonsoft.Json;
using XrmFramework.Core;

namespace XrmFramework.Analyzers.Generators;

[Generator]
public class TableJsonDefinitionGenerator : BaseTableDefinitionGenerator
{
	protected override bool GenerateTableFiles => true;

	protected override void WriteTable(SourceProductionContext productionContext, TableCollection tables, Table table, HashSet<string> alreadyCreatedEnums)
	{
		var sb = new IndentedStringBuilder();

		int count;



        WriteHeaders(sb);

		sb.AppendLine($"const {table.LogicalName}Definition = {{");

		using (sb.Indent())
		{
			WriteEntityMetadata(sb, table);

			sb.AppendLine("Columns: {");
			using (sb.Indent())
			{
				/*
                if (!table.Columns.Any())
                {
                    return;
                }
				*/
				count = 0;
                foreach (var col in table.Columns)
				{
					count++;
					WriteColumn(sb, col, count != table.Columns.Count);
				}
			}
			sb.AppendLine("},");

			sb.AppendLine("Enums: {");
			using (sb.Indent())
			{
				count = 0;
				foreach (var optionSetEnum in table.Enums)
				{
                    count++;
                    WriteEnum(sb, optionSetEnum, count != table.Enums.Count);
				}
			}
            sb.AppendLine("}");
        }

		sb.AppendLine("};");


        //On crée le chemin pour cette table
        productionContext.AddSource($"{table.Name}Definition.json", SourceText.From(sb.ToString(),System.Text.Encoding.UTF8));
	}

	private void WriteEnum(IndentedStringBuilder sb, OptionSetEnum optionSetEnum, bool withComa)
	{
		sb.AppendLine($"{optionSetEnum.Name}: {{");
		List<string> nameUse = new List<string>();
		using (sb.Indent())
		{
			int count = 0;
			foreach (var value in optionSetEnum.Values)
			{
				count++;
				string name = AvoidWordThatBeginByANumber(DeleteCharacter(value.Name, ';'));
				int nameTimeUsed = HowManyTimeThisWordIsInList(name, nameUse);
				nameUse.Add(name);

				if (nameTimeUsed != 0) name = name + nameTimeUsed.ToString();

				if(count == optionSetEnum.Values.Count)
					sb.AppendLine($"{name}: {value.Value}");
				else
                    sb.AppendLine($"{name}: {value.Value},");
            }
		}
		if(withComa)
            sb.AppendLine("},");
        else
            sb.AppendLine("}");

    }

	private void WriteColumn(IndentedStringBuilder sb, Column col, bool withComa)
	{
		if(withComa)
            sb.AppendLine($"{col.Name}: \"{col.LogicalName}\",");
        else
			sb.AppendLine($"{col.Name}: \"{col.LogicalName}\"");
	}

	private void WriteEntityMetadata(IndentedStringBuilder sb, Table table)
	{
		sb.AppendLine($"LogicalName: \"{table.LogicalName}\",");
		sb.AppendLine($"SchemaName: \"{table.Name}\",");
		sb.AppendLine($"CollectionName: \"{table.CollectionName}\",");
		sb.AppendLine($"LogicalCollectionName: \"{table.CollectionName}\",");
		sb.AppendLine($"PrimaryIdAttribute: \"{table.Columns.FirstOrDefault(c => c.PrimaryType   == PrimaryType.Id)?.LogicalName}\",");
		sb.AppendLine($"PrimaryNameAttribute: \"{table.Columns.FirstOrDefault(c => c.PrimaryType == PrimaryType.Name)?.LogicalName}\",");
	}

	private void WriteHeaders(IndentedStringBuilder sb)
	{
		sb.AppendLine("/*");
		sb.AppendLine(" * Auto generated by XrmFramework 2.0");
		sb.AppendLine(" * Do not edit directly this file");
		sb.AppendLine(" */");
	}


	private void AddColumnSummary(IndentedStringBuilder sb, Column col, OptionSetEnum? optionSetEnum)
	{
		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// ");
		sb.AppendLine($"/// Type: {col.Type}{(optionSetEnum == null ? "" : " (" + optionSetEnum.Name + ")")}");
		sb.Append("/// Validity:  ");

		var isFirst = true;
		if ((col.Capabilities & AttributeCapabilities.Read) != AttributeCapabilities.None)
		{
			isFirst = false;
			sb.Append("Read ");
		}

		if ((col.Capabilities & AttributeCapabilities.Create) != AttributeCapabilities.None)
		{
			if (isFirst)
				isFirst = false;
			else
				sb.Append("| ");
			sb.Append("Create ");
		}

		if ((col.Capabilities & AttributeCapabilities.Update) != AttributeCapabilities.None)
		{
			if (isFirst)
				isFirst = false;
			else
				sb.Append("| ");
			sb.Append("Update ");
		}

		if ((col.Capabilities & AttributeCapabilities.AdvancedFind) != AttributeCapabilities.None)
		{
			if (!isFirst) sb.Append("| ");

			sb.Append("AdvancedFind ");
		}

		sb.AppendLine();

		sb.AppendLine("/// </summary>");
	}

	private void AddRelations(IndentedStringBuilder sb, TableCollection tables, Table table, List<Relation> relations,
	                          string relationType)
	{
		if (relations.Any())
		{
			sb.AppendLine($"public static class {relationType}");
			sb.AppendLine("{");
			using (sb.Indent())
			{
				foreach (var relationship in relations)
				{
					if (relationType != "ManyToOneRelationships")
						if (!tables.Any(t => t.LogicalName == relationship.EntityName))
							continue;
					sb.Append("[Relationship(");
					var targetTable = tables.FirstOrDefault(t => t.LogicalName == relationship.EntityName);
					if (targetTable != null)
						sb.Append($"{targetTable.Name}Definition.EntityName");
					else
						sb.Append($"\"{relationship.EntityName}\"");

					sb.Append($", EntityRole.{relationship.Role}, \"{relationship.NavigationPropertyName}\", ");


					if (relationType == "ManyToOneRelationships")
					{
						if (relationship.Role == EntityRole.Referencing)
						{
							var rc = table.Columns.FirstOrDefault(
								col => col.LogicalName == relationship.LookupFieldName);

							if (rc != null && rc.Selected)
								sb.Append($"{table.Name}Definition.Columns.{rc.Name}");
							else
								sb.Append($"\"{relationship.LookupFieldName}\"");
						}
						else
						{
							var rc = table.Columns.FirstOrDefault(
								col => col.LogicalName == relationship.LookupFieldName);


							if (rc != null)
								sb.Append($"{table.Name}Definition.Columns.{rc.Name}");
							else
								sb.Append($"\"{relationship.LookupFieldName}\"");
						}

						sb.AppendLine(")]");
						sb.AppendLine($"public const string {relationship.Name} = \"{relationship.Name}\";");
					}
					else
					{
						if (relationship.Role == EntityRole.Referencing)
						{
							var tb = tables.FirstOrDefault(t => t.LogicalName          == relationship.EntityName);
							var rc = tb?.Columns.FirstOrDefault(col => col.LogicalName == relationship.LookupFieldName);

							if (rc != null && rc.Selected && tb != null)
								sb.Append($"{tb.Name}Definition.Columns.{rc.Name}");
							else
								sb.Append($"\"{relationship.LookupFieldName}\"");
						}
						else
						{
							var tb = tables.FirstOrDefault(t => t.LogicalName == relationship.EntityName);

							var rc = tb?.Columns.FirstOrDefault(col => col.LogicalName == relationship.LookupFieldName);

							if (rc != null && rc.Selected && tb != null)
								sb.Append($"{tb.Name}Definition.Columns.{rc.Name}");
							else
								sb.Append($"\"{relationship.LookupFieldName}\"");
						}

						sb.AppendLine(")]");
						sb.AppendLine($"public const string {relationship.Name} = \"{relationship.Name}\";");
					}
				}
			}

			sb.AppendLine("}");
		}
	}

	private string DeleteCharacter(string word, char letterToDelete)
	{
		if (word == String.Empty) return word;
		string[] list = word.Split(letterToDelete);
		return string.Concat(list);
	}


    private string AvoidWordThatBeginByANumber(string word)
	{
		if (word == String.Empty) return word;
		if (word == null) return null;
		int i = 0;
		if (int.TryParse(word.Substring(0,1), out i)) return "_"+word;
		else return word;
	}

    private string AvoidWordThatBeginByASubWord(string word, string subWord)
    {
        if (word == String.Empty) 
			return word;
        if (word == null) 
			return null;
		if(word.Length < subWord.Length) 
			return word;
        
		if(word.Substring(0, subWord.Length)  == subWord) 
			return word.Substring(subWord.Length);
		
		return word;

    }

	private int HowManyTimeThisWordIsInList(string word, List<string> list)
	{
		if(list.Count == 0) return 0;
		return list.FindAll(
			delegate(string element)
			{
				return element == word;
			}
			).Count;
	}
}
